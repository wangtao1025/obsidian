# Python 语法手册：循环遍历( while 与 for)

← [语法手册总览](/) | 下一章见总览

---

## 十、循环遍历( while 与 for)

核心直觉： **`for` 是为了“数完”或“走完”，`while` 是为了“等到”。**
### 10.1 循环动力引擎：`range()`
#### 10.1.1 语法
`range` 不是列表，而是一个**“懒惰”的数字工厂**，只在循环需要时才生产下一个数字，极其节省内存。
1. **`range(stop)`**：生成从`0`开始，到`stop`结束（不包含`stop`）的整数序列
2. **`range(start, stop)`**：生成从`start`开始，到`stop`结束（不包含`stop`）的整数序列
3. **`range(start, stop, step)`**：生成从`start`开始，到`stop`结束（不包含`stop`），并以`step`为步长的整数序列
其中：
- `stop`参数是一个限定值，序列不包含此值
- `start`参数定义了序列的起始值（默认为`0`）
- `step`参数表示序列中相邻数字之间的步长（默认为`1`）
#### 10.1.2 高级特性
- range对象与列表的转换
	- `range()`函数生成的是一个`range`对象，而不是一个实际的列表。`range`对象是可迭代的，但它并不会在内存中立即生成所有数字。如果需要将其转换为列表，可以使用`list()`函数。
	```python
	# 生成一个range对象，表示从0到4的序列
	my_range_object = range(5)
	# 将range对象转换为列表并打印
	print(list(my_range_object))
	```
- 内存效率
	 - `range`对象具有非常高的内存效率。它们并不会真正地在内存中存储所有数字，而是依赖于一个算法来在需要时生成这些数字。这意味着即使是生成非常大的序列（例如`range(10**9)`），也不会占用大量内存。
	```python
	# 创建一个非常大的range对象
	large_range = range(10**6)
	# 打印range对象的内存占用（非常小）
	print(f"range对象大小: {large_range.__sizeof__()} 字节")# 48 字节
	
	# 如果转换为列表，内存占用会很大
	large_list = list(large_range)  # 这会占用大量内存
	print(f"列表大小: {large_list.__sizeof__()} 字节")#8000040 字节
	```
- 生成递减序列
	- `range()`函数也可以用于生成递减的序列。这需要满足两个条件：`start`值必须大于`stop`值，并且`step`值必须是负数。
	```python
	# 定义序列的起始值
	start_value = 5
	# 定义序列的停止值
	stop_value = 0
	# 定义负数步长，实现递减
	negative_step = -1
	# 遍历从start_value到stop_value+1，步长为negative_step的整数
	for i in range(start_value, stop_value, negative_step):
	    # 打印当前整数
	    print(i)
	```
- `range` 支持切片操作
	- `range`对象支持切片操作，尽管这个特性不常见。切片操作会返回一个新的`range`对象。
	```python
	# 创建一个从0到9的range对象
	r = range(10)
	print(list(r))#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	# 对range对象进行切片操作：从索引2开始，到索引8结束（不包含），步长为2
	# 结果将是range(2, 8, 2)
	print(r[2:8:2])
	# 将切片结果转换为列表查看
	print(list(r[2:8:2]))#[2, 4, 6]
	```

### 10.2  `break`, `continue`, `pass`, `return`
| **关键字**        | **作用范围 (破坏半径)** | **形象理解**   | **场景示例**                  |
| -------------- | --------------- | ---------- | ------------------------- |
| **`pass`**     | **0 (无影响)**     | **“此处招租”** | 还没想好 `if` 后面的逻辑，先占个位防止报错。 |
| **`continue`** | **当前这一次迭代**     | **“这题跳过”** | 遇到脏数据（如 `None`），直接进入下一轮。  |
| **`break`**    | **最近的一层循环**     | **“原地爆破”** | 找到目标数据后立即收工，不再跑剩下的循环。     |
| **`return`**   | **整个函数**        | **“终结者”**  | 无论嵌套几层循环，直接关掉函数并带走结果。     |
